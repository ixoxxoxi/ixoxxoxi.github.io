{"posts":[{"title":"B站vue面试题","content":"1.vue3响应式为什么使用Proxy替代Object.defineProperty() new Proxy(obj,{ get(target,key,receiver){ // 收集副作用函数 const res=Reflect.get(target,key,receiver); return res; }, set(target,key,value,receiver){ // 触发更新 const res=Reflect.set(target,key,value,receiver); return res; } }) 1.Object.defineProperty只能遍历对象属性进行劫持，无法检测对象属性的添加和移除，Vue2为了解决这个问题提供了$set和$delete实例方法，Proxy可以劫持整个对象，并返回一个新对象，通过操作新对象来达到响应式目的； 2.Object.defineProperty无法监控到数组下标及数组长度的变化，Proxy可以直接监听数组的变化(push、shift、splice)； 3.Proxy有多达13种拦截方法，不限于apply、ownKeys、deleteProperty、has等，这是Object.defineProperty不具备的; 4.性能问题，当data中数据比较多且层级很深的时候，Object.defineProperty要遍历data中所有数据并给其设置响应式，会导致性能下降；Proxy只在getter时才对对象的下一层进行劫持(优化了性能)，真正访问到的内部对象才会变成响应式; 2.vue中watch和computed的使用差异是什么 const count=ref(0); watch(count,(newVal,oldVal)=&gt;{ // 回调 }) const obj=reactive({ a:1, b:2 }) const c=computed((=&gt;obj.a+obj.b)); 1.计算属性会自动追踪响应式依赖，当响应式数据改变时，会重新计算并缓存计算结果。computed和methods的差异是它具备缓存性，方法调用总会在重渲染发生时再次执行函数。 2.计算属性默认总是只读的，当需要用到“可写”的属性，可以通过同时提供getter和setter来创建。 3.不要在计算属性getter中做异步请求或者更改DOM，计算属性的getter应只做计算而没有任何其他副作用。 4.使用watch函数在每次响应式状态发生变化时触发回调函数，可以在回调中执行异步操作等复杂逻辑。 5.通过设置immediate可以在侦听器创建时立即触发回调，指明flush:'post'可以异步执行回调函数。 3.什么是虚拟DOM？ var vnode={ type:'div', props:{ id:'foo' }, children:[{ type:'p', children:'hello word' }] } 1.虚拟DOM是描述真实DOM结构及其属性信息的JS对象； 2.使用虚拟DOM能够有效减少直接操作DOM的次数，改为查找JS对象的属性变化，从而提高程序性能； 3.使用虚拟DOM可实现跨平台，根据虚拟DOM可以渲染成不同平台上对应的内容，如原生App(Android、ios)，小程序、浏览器等； 4.虚拟DOM通过diff算法，将前后两次的虚拟DOM树进行对比，定位出具体需要更新的部分，最终在真实DOM中局部渲染。 4.vue中nextTick()有什么作用？ // nextTick代码实现 function nextTick(fn) { const p2 = Promise.resolve(); return fn ? p2.then(this ? fn.bind(this) : fn) : p2; } // 使用方法 async function increment() { Number.value++; // DOM还未更新 输出0 console.log(document.getElementById('num').textContent); await nextTick(); // DOM此时已经更新 输出1 console.log(document.getElementById('num').textContent); } 1.nextTick()是等待下一次DOM更新刷新的工具方法，可以在状态改变后立即使用，以等待DOM更新完成。你可以传递一个回调函数作为参数，或者await返回Promise； 2.Vue中如果数据变化，Vue不会立刻更新DOM，而是开启一个队列，把组件更新函数保存在队列中，等同一事件循环发生的所有数据变更完成后，再统一对视图进行更新。此时如果想要获取更新后的DOM状态，就可以使用nextTick()； 3.使用场景：在created或setup中想要获取DOM时，在响应式数据变化后获取DOM更新后的状态时； 5.vue组件间如何通信？ const props = defineProps(['foo']); console.log(props.foo); const emit = defineEmits(['inFocus', 'submit']); function buttonClick() { emit('submit') } const count = ref(0); provide('key', count); const message = inject('message'); 1.props/emits 父组件通过props向子组件传递数据，子组件通过emit方法和父组件通信。所有的props都遵循着单向绑定原则，即单向数据流，props因父组件的更新而变化，自然德将新的状态向下流往子组件，而不会逆向传递，这避免了子组件意外修改父组件的状态的情况，不然应用的数据流将很容易变得混乱而难以理解，子组件应该抛出一个事件来通知父组件做出改变。 2.provide/inject 有一些多层级嵌套的组件，形成了一颗巨大的组件树，而某个深层次的子组件需要一个较远组件中的部分数据，在这种情况下，如果仅适用props则必须将其沿着组件链逐级传递下去，这会非常麻烦，provide和inject可以帮助我们解决这一问题，一个父组件相对于其所有的后代组件，会作为依赖提供者，任何后代的组件树，无论层级多深，都可以注入由父组件提供给整条链路的依赖，当提供/注入响应式数据时，建议尽可能将任何对响应式状态的变更都保持在供给方组件中，我们可能需要在注入组件中更改数据，在这种情况下，我们推荐在供给方组件内声明并提供一个更改数据的方法函数。 3.vuex/pinia 当我们的应用遇到多个组件共享状态时，推荐使用此方法。 6.谈谈你对keep-alive的了解？ &lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt; &lt;!--被缓存的页面--&gt; &lt;/router-view&gt; &lt;/keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt; &lt;!--不缓存的页面--&gt; &lt;/router-view&gt; &lt;keep-alive&gt;&lt;/keep-alive&gt;是一个内置组件，它的功能是在多个组件间动态切换时缓存被移除的组件实例。&lt;keep-alive&gt;&lt;/keep-alive&gt;它包裹动态组件时，会缓存不活跃的组件实例，而不是销毁它们。任何时候都只能有一个活跃组件实例作为&lt;keep-alive&gt;&lt;/keep-alive&gt;的直接子节点。 1.一般结合路由vue-router和动态组件一起使用，用于缓存组件； 2.提供include和exclude属性，include表示只有名称匹配的组件会被缓存，exclude表示任何名称匹配的组件都不会缓存；这两个prop的值都可以是一个以英文逗号分隔的字符串。一个正则表达式，或者是包含这两种类型的一个数组。 3.max prop来限制可被缓存的最大组件实例数。&lt;keep-alive&gt;&lt;/keep-alive&gt;的行为在指定max后类似一个LRU缓存；如果缓存的实例数量即将超过指定的那个最大数量，则最久没有被访问的缓存实例将被销毁，以便为新的实例腾出空间。 4.当一个组件在&lt;keep-alive&gt;&lt;/keep-alive&gt;中被切换时，它的Actived和deactivated生命周期钩子将被调用，用来替代mounted和unmounted。这适用于直接子节点及其所有子孙节点。 7.vue-router中常用的路由工作模式 const routes = [ { path: '/', component: Home }, { path: '/about', component: Posts } ]; const router = createRouter({ history: createWebHashHistory(), routes }) let app = createApp(App); app.use(router); vue-router目前支持三种模式，hash模式、HTML5模式和memory模式，我们常用的是前两种模式。 1.hash模式 基于location.hash来实现的，location.hash的值就是URL中#后面的内容，不过对SEO有不好的影响。 1.URL中hash值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash部分不会被发送，改变hash不会重新加载页面。 2.hash值得改变，都会在浏览器的访问历史中增加一个记录，因此我们能通过浏览器的回退、前进控制hash的切换。 3.可以使用`hashChange`事件来监听hash值得变化。 2.HTML5模式 HTML5提供了History API history.pushState()和history.replaceState()，可以在不进行刷新的情况下，操作浏览器的历史记录，需要在服务器上添加一个简单的回退路由，如果URL不匹配任何静态资源，应提供应用程序中的index.html相同的页面。 1.`history.pushState()`和`history.replaceState()`两个API来操作实现URL的变化； 2.可以使用`propstate`事件来监听URL的变化，从而对页面进行跳转(渲染); 3.`history.pushState()`和`history.replaceState()`不会触发`propstate`事件，这时我们需要手动触发页面跳转(渲染)。 8.说一说vue的生命周期钩子函数？ &lt;template&gt; &lt;button id=&quot;count&quot; @click=&quot;count++&quot;&gt;{{count}}&lt;/button&gt; &lt;/template&gt; &lt;script setup&gt; import {ref,onUpdated} from 'vue'; const count=ref(0); onUpdated(()=&gt;{ var a=document.getElementById('count').textContent; }) &lt;/script&gt; 在vue3中，setup函数替代了vue2的beforeCreate和created钩子函数。 onBeforeMount() 在组件被挂载之前调用，当这个钩子函数被调用时，组件已经完成了其响应式状态的设置，但还没有创建DOM节点，即将首次执行DOM渲染过程。 onMounted() 在组件挂载完成后执行，当调用onMounted时，vue会自动将回调函数注册到当前被初始化的组件实例上，这意味着这些钩子应当在组件初始化时被同步注册，其所有同步子组件都已经被挂载，其自身的DOM树已经创建完成并插入了父容器中，这个钩子通常用于执行需要访问组件所渲染的DOM树相关的副作用，对于嵌套组件，组件在挂载相关的生命周期钩子函数时，先执行父组的beforeMount，然后是子组件的beforeMount，接着是子组件的mounted，最后执行父组件的mounted。 onBeforeUpdate() 在组件即将因为响应式状态变更而更新其DOM树之前调用，在beforeUpdate钩子函数执行时，组件的DOM还未更新，如果你想在组件更新前访问DOM，比如手动移除已添加的事件监听器，你可以注册这个钩子函数。 onUpdated() 在组件因为响应式状态变更而更新DOM树之后调用，父组件的更新钩子将在其子组件的更新钩子之后调用，如果要监听数据的改变并执行某些逻辑，最好不要使用updated钩子函数，而用计算属性或watcher取代。因为任何数据的变化导致组件更新都会执行updated钩子函数，注意：不要在updated钩子函数中更改数据，因为这样会再次触发组件更新，导致无限递归更新，父组件的更新不一定导致子组件的更新，因为更新粒度是组件级别的。 onBeforeUnmount() 在组件实例被卸载之前调用，当这个钩子被调用时，组件实例依然还保有全部功能。 onUnmounted() 在组件实例被卸载之后调用，其所有子组件都已经被卸载，可以在这个钩子函数手动清理一些副作用，例如计时器、DOM事件监听器或者与服务器断开连接。 onErrorCaptured() 注册一个钩子，在捕获了后代组件传递的错误时调用。 ","link":"https://ixoxxoxi.github.io/post/b-zhan-vue-mian-shi-ti/"},{"title":"Vue2/3面试题(51-60)","content":"51. 在Vue中实现条件渲染渲染有哪些办法？ v-if v-else-if v-else v-show &lt;component :is=&quot;componentId&quot;&gt;&lt;/component&gt; 52. 路由跳转时如何传递数据？ 动态路由： 1）path: /user/:id 2）获取动态路由的值的⽅式如下： 3）在template中，直接通过 $route.params获取值 4）在created中，通过 this.$route.params获取值 5）在setup中，使⽤ vue-router 库提供的⼀个hook useRoute（该Hook会返回⼀个Route对象，对象中保存着当前路由相关的值） query参数: 1）通过query的⽅式来传递参数 2）在界⾯中通过 $route.query 来获取参数 3）在created中，通过 this.$route.query 获取值 4）在setup，使⽤ vue-router 库提供的⼀个hook useRoute 来获取 53. 计算属性有什么作用？（两大作用） Tips:可以研究一下，计算属性的实现原理。找资料，找视频，回答：我之前看过vue的源码，它的计算属性是xxxx实现的。 作用1：当指令的表达式比较复杂时，我们建议使用计算属性来优化，提升视图模板中代码的可阅读性、可维护性。 作用2：用于缓存一个复杂的运算，避免组件更新时产生没有必要的性能损耗。计算属性本质上是一个函数，Vue会分析函数体中使用到了哪些声明式变量，有且仅有这些声明式变量发生变化时，计算属性才会重新执行。 54. 什么是路由守卫？路由守卫有什么作⽤？ vue-router 提供的路由(导航)守卫主要⽤来通过跳转或取消的⽅式守卫导航。有很多种⽅式植⼊路由导航中：全局的，单个路由独享的，或者组件级的。 全局导航钩⼦ 全局前置守卫 const router = new VueRouter({ ... }) router.beforeEach((to, from, next) =&gt; { // ... }) 全局解析守卫 在 2.5.0+ 你可以用 router.beforeResolve 注册一个全局守卫。这和 router.beforeEach 类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。 全局后置钩子 router.afterEach((to, from) =&gt; { // ... }) 路由独享的守卫 在路由配置上直接定义 beforeEnter 守卫 const router = new VueRouter({ routes: [ { path: '/foo', component: Foo, beforeEnter: (to, from, next) =&gt; { // ... } } ] }) 这些守卫与全局前置守卫的方法参数是一样的 组件内的钩⼦ const Foo = { template: `...`, beforeRouteEnter(to, from, next) { // 在渲染该组件的对应路由被 confirm 前调用 // 不！能！获取组件实例 `this` // 因为当守卫执行前，组件实例还没被创建 }, beforeRouteUpdate(to, from, next) { // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` }, beforeRouteLeave(to, from, next) { // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this` } } beforeRouteEnter 守卫 不能 访问 this，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建。 不过，你可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。 beforeRouteEnter (to, from, next) { next(vm =&gt; { // 通过 `vm` 访问组件实例 }) } 注意 beforeRouteEnter 是支持给 next 传递回调的唯一守卫。对于 beforeRouteUpdate 和 beforeRouteLeave 来说，this 已经可用了，所以不支持传递回调，因为没有必要了。 beforeRouteUpdate (to, from, next) { // just use `this` this.name = to.params.name next() } 这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next(false) 来取消。 beforeRouteLeave (to, from, next) { const answer = window.confirm('Do you really want to leave? you have unsaved changes!') if (answer) { next() } else { next(false) } } 单独路由独享组件 1) beforeEnter: (to, from, next) 2) afterEach(to,from) 3)... 路由守卫作⽤ 1)可以在进⼊路由之前进⾏某些判断，⽐如，检查token是否存在来判断⽤户是否已经登录。 2)可以在路由守卫中进⾏⻚⾯的权限判断，⽐如，判断某个⽤户是否拥有该⻚⾯的权限。 3)也可以⽤来记录⻚⾯的某些信息，⽐如，记录⻚⾯的滚动信息等等。 完整的导航解析流程 导航被触发。 在失活的组件里调用 beforeRouteLeave 守卫。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。 在路由配置里调用 beforeEnter。 解析异步路由组件。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫 (2.5+)。 导航被确认。 调用全局的 afterEach 钩子。 触发 DOM 更新。 12 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。 55.route和router的区别 route是路由信息对象，在Vue3中通过 useRoute 来获取。 1)包括了path，params，hash，query，fullPath，matched，name等路由信息参数。 router是路由实例”对象，在Vue3中通过 useRouter 来获取。 1)包括了路由跳转⽅法、钩⼦函数等，⽐如：push、go、back、addRouter、beforeEnter等。 56.vue 中怎么阻止冒泡？怎么阻止默认事件？怎么监听键盘enter键？ 阻止冒泡和默认事件： 1）通过事件对象 2）事件事件修饰符 监听键盘enter键： 1）通过事件对象 2）通过按键修改符 &lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt; &lt;input v-on:keyup.enter=&quot;submit&quot;&gt; 其他情况(官网示例)： &lt;!-- 阻止单击事件继续传播 --&gt; &lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt; &lt;!-- 提交事件不再重载页面 --&gt; &lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt; &lt;!-- 修饰符可以串联 --&gt; &lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt; &lt;!-- 只有修饰符 --&gt; &lt;form v-on:submit.prevent&gt;&lt;/form&gt; &lt;!-- 添加事件监听器时使用事件捕获模式 --&gt; &lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt; &lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt; &lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt; &lt;!-- 即事件不是从内部元素触发的 --&gt; &lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt; &lt;!-- 点击事件将只会触发一次 --&gt; &lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt; &lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt; &lt;!-- 而不会等待 `onScroll` 完成 --&gt; &lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt; &lt;div v-on:scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt; &lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt; &lt;input v-on:keyup.enter=&quot;submit&quot;&gt; &lt;!-- 你可以直接将 KeyboardEvent.key 暴露的任意有效按键名转换为 kebab-case 来作为修饰符 --&gt; &lt;input v-on:keyup.page-down=&quot;onPageDown&quot;&gt; &lt;!-- .exact 修饰符允许你控制由精确的系统修饰符组合触发的事件 --&gt; &lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt; &lt;button v-on:click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt; &lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt; &lt;button v-on:click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt; &lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt; &lt;button v-on:click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt; 57. 什么是状态管理？什么是单项数据流？ 在开发中，应⽤程序是需要处理各种各样的数据，这些数据需要保存在应⽤程序中的某⼀个位置，对于这些数据的管理就称之为是 状态管理。以前我们是如何管理应⽤程序的状态？ 1）在Vue开发中，我们使⽤组件化的开发⽅式。⽽在组件中我们定义的data或在setup中返回的数据，这些数据我们称之为状态（State）。 2）在模块template中我们可以使⽤这些数据，模块最终会被渲染成DOM，我们称之为View。 3）在模块中我们会产⽣⼀些⾏为事件，处理这些⾏为事件时，有可能会修改State，这些⾏为事件我们称之为Actions。 其实Vue组件内部的数据是以单向数据流的形式来管理数据的。 例如，组件的数据定义在State中，接着在View层使⽤State中的数据，然后View层会产⽣⼀些事件Actions，⽽这些Actions可能会修改State的数据，这就是⼀个单项数据流的概念。 58. 什么是Vuex？你使⽤过 Vuex 吗？ vuex 是⼀个专为 Vue.js 应⽤程序开发的状态管理模式。每⼀个 Vuex 应⽤的核⼼就是 store（仓库）。“store” 基本上就是⼀个容器，它包含着你的应⽤中⼤部分的状态 ( state )。 1）Vuex 的状态存储是响应式的。 当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发⽣变化，那么相应的组件也会相应地得到⾼效更新。 2)改变 store 中的状态的唯⼀途径就是显式地提交 (commit) mutation。这样使得我们可以⽅便地跟踪每⼀个状态的变化。 Vuex包括⼀下⼏个核⼼模块： 1)State：定义了应⽤状态的数据结构，可以在这⾥设置默认的初始状态。 2)Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到计算属性。 3)Mutation：是唯⼀更改 store 中状态的⽅法，且必须是同步函数。 4)Action：⽤于提交 mutation，⽽不是直接变更状态，可以包含任意异步操作。 5)Module：允许将单⼀的 Store 拆分为多个 store 且同时保存在单⼀的状态树中。 59.v-model 有哪些修饰符？ .trim .lazy .number v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件： text 和 textarea 元素使用 value property 和 input 事件； checkbox 和 radio 使用 checked property 和 change 事件； select 字段将 value 作为 prop 并将 change 作为事件。 60. Vue中怎么做动画？ 内置组件transition，使用那6个类名编写自定义动画 enter-class enter-active-class enter-to-class leave-class leave-active-class leave-to-class v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。 v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 v-enter-to：2.1.8 版及以上定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。 v-leave：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。 v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 v-leave-to：2.1.8 版及以上定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。 使用animate.css第三方动画 示例： &lt;link href=&quot;https://cdn.jsdelivr.net/npm/animate.css@3.5.1&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt; &lt;div id=&quot;example-3&quot;&gt; &lt;button @click=&quot;show = !show&quot;&gt; Toggle render &lt;/button&gt; &lt;transition name=&quot;custom-classes-transition&quot; enter-active-class=&quot;animated tada&quot; leave-active-class=&quot;animated bounceOutRight&quot; &gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; new Vue({ el: '#example-3', data: { show: true } }) ","link":"https://ixoxxoxi.github.io/post/vue2&3-51-60/"},{"title":"Vue2/3面试题(41-50)","content":"41.vue-router路由的两种模式 vue-router中默认使⽤的是hash模式： 1）hash模式，带#。如：http://localhost:8080/#/page。改变hash，浏览器本身不会有任何请求服务器动作。 2）history模式，不带#， 如：http://localhost:8080/page ，路径没有#。基于HTML5的pushState、replaceState实现。 hash: 1)有#号 2)能够兼容到IE8 3)实际的url之前使⽤哈希字符，这部分url不会发送到服务器，不需要在服务器层⾯上进⾏任何处理 4)刷新不会存在404问题 5)不需要服务器任何配置 history: 1)没有 # 号 2)只能兼容到IE10 3)每访问⼀个⻚⾯都需要服务器进⾏路由匹配⽣成html⽂件再发送响应给浏览器，消耗服务器⼤量资源 4)浏览器直接访问嵌套路由时，会报 404 问题。 5)需要在服务器配置⼀个回调路由 42. 在创建/挂载/更新/销毁阶段，Vue在背后分别做了些什么事儿？ Vue的生命周期指的是组件从“生”到“死”的全过程，一共分四个阶段，不同阶段有不同的钩子函数： 创建阶段：beforeCreate、created 挂载阶段：beforeMount、mounted 更新阶段：beforeUpdate、updated 销毁阶段：beforeDestroy、destroyed 与动态组件有关的两个特殊的钩：activated(激活)、deactivated(休眠) 与组件异常捕获有关的一个钩子：errorCaptured 在beforeCreate之前会声明methods中的方法和声明生命周期钩子函数，这个钩子函数我们用的并不多 在created之前会注入一些数据，初始化响应式系统，我们通常在这个钩子函数中调接口，获取路由参数等 在beforeMount之前会通过el $mount template找模板，会把模块变成render函数 调用render函数创建虚拟DOM，虚拟DOM转化成真实DOM，进行挂载，通常这个钩子函数我们也用不到 在mounted时，已表示真实DOM已挂载完毕，我们在这个钩子中通常调接口，开定时器，DOM操作，建立websocket连接 实例化echarts实例等。 当数据变化时，会触发beforeUpdate钩子，这个钩子通常也用不到。 在updated之前，要生成新的虚拟DOM，新的虚拟DOM和老的虚拟DOM进行对比，会执行patch运算，diff算法，找到两个虚拟DOM的最小差异，找到后，进行异步更新，key的目的就是最快找到最小差异，这个钩子也不常用，但是有点类似于watch侦听器或类似于$nextTick()，我们不能在这个钩子中更新数据，会导致死循环。 当我们手动调用$destory()或路由切换时，会调用beforeDestroy这个钩子函数，我们可以在这个钩子函数中清空定时器，解除事件绑定，清除缓存... 当组件销毁时，就会移除当前组件的watcher，DOM就无法再更新，移除所有子组件，移除事件监听器，响应式系统就会失效，组件就死亡了，这个钩子函数我们用的也不多。 43. 响应式原理，发生在Vue哪些生命周期阶段？ 在created之前会注入一些数据，初始化响应式系统，我们通常在这个钩子函数中调接口，获取路由参数等 44. 虚拟DOM，在哪些阶段生成的？ 在beforeMount之前会通过el $mount template找模板，会把模块变成render函数，调用render函数创建虚拟DOM，虚拟DOM转化成真实DOM，进行挂载，通常这个钩子函数我们也用不到 在updated之前，要生成新的虚拟DOM，新的虚拟DOM和老的虚拟DOM进行对比，会执行patch运算，diff算法，找到两个虚拟DOM的最小差异，找到后，进行异步更新，key的目的就是最快找到最小差异，这个钩子也不常用，但是有点类似于watch侦听器或类似于$nextTick()，我们不能在这个钩子中更新数据，会导致死循环。 45. 哪些生命周期钩子可以执行多次？哪些执行一次？ 更新阶段：beforeUpdate、updated 与动态组件有关的两个特殊的钩：activated(激活)、deactivated(休眠) 上面四个钩子函数执行多次。 46. 什么虚拟DOM？ 是一个很大的JSON数据，用于描述视图模板的，保存在内存中 47. 谈一谈你对 MVVM、MVC、MVP的理解？ MVVM流程 : M数据层 -&gt; VM虚拟DOM层 -&gt; V视图层 网页本质 = M数据层 + V视图结构 M+V是怎么组装的？（ MVC MVP MVVM） M+V在哪儿组装？（前后端分离、前后端不分离、SSR服务端渲染） 进一步理解（阮一峰博客）：https://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html 48.mounted和activated有什么区别？deactivated和beforeDestroy有什么区别？（执行次数、使用场景） 这两组钩子的区别和使用场景： activated(执行多次) mounted(执行一次) deactivated(执行多次) beforeDestroy(执行一次) 动态组件的作用： 1）有种v-if的感觉，根据指定条件渲染目标组件，它的is属性等于哪个组件，就显示哪个组件。 2）场景：它经常配合keep-alive一起使用。 3）activated(激活)、deactivated(休眠) 普通组件的挂载与销毁： 1）mounted挂载 2）beforeDestroy将要销毁 49. Vue有哪些内置组件？ component transition transition-group keep-alive slot 50. 哪些场景下你会用到动态组件？ 动态组件也是为了实现条件渲染，在需要使用条件渲染地方，根据不同的组件，渲染不到组件，都可以使用动态组件。 ","link":"https://ixoxxoxi.github.io/post/vue2&3-41-50/"},{"title":"Vue2/3面试题(31-40)","content":"31. 你工作中有没有封装比较好的组件？ ↑↑↑同第5题↑↑↑ Tips:面试之前，需要封装几个组件，真实开发中，不会自己封装，都是用第三方封装好的，或公司自己的组件库。 32. 说说Vue插槽的作⽤和平时开发中的应⽤？ 插槽的作⽤: 1）⽀持在⽗组件⾃定义⼦组件中的个内容 2）让⼦组件更具有通⽤性，不必限定死某个内容 插槽平时开发中的应⽤: 1）在封装组件时，如果组件中的某个内容是动态的或不确定的，就可以使⽤插槽来代替了。 2）在使⽤第三⽅库时，往往会通过使⽤插槽类⾃定义第三⽅组件中的某些内容。 33.⽗⼦组件的⽣命周期顺序 加载渲染过程： ⽗beforeCreate -&gt; ⽗created -&gt; ⽗beforeMount -&gt; ⼦beforeCreate -&gt; ⼦created -&gt; ⼦beforeMount -&gt;⼦mounted -&gt; ⽗mounted ⼦组件更新过程：⽗beforeUpdate -&gt; ⼦beforeUpdate -&gt; ⼦updated -&gt; ⽗updated ⽗组件更新过程：⽗beforeUpdate -&gt; ⽗updated 销毁过程：⽗beforeDestroy -&gt; ⼦beforeDestroy -&gt; ⼦destroyed -&gt; ⽗destroyed 34. 什么是Composition API 和 Options API？ Composition API是⼀组 API，允许我们使⽤导⼊的函数⽽不是声明选项来编写 Vue 组件。它是⼀个涵盖以下 API 的总称：Reactivity API、Lifecycle Hooks、Dependency Injection等等 使⽤Composition API编写组件时可以根据逻辑功能来组织代码。⽐如可以把⼀个功能所⽤到的API放在⼀起，这样可以让代码⾼内聚和低耦合，进⽽提⾼了代码的逻辑的复⽤性。在 Vue 3 中，它也主要与script setup语法⼀起使⽤。 Options API是指在对应的属性中编写对应的功能模块, ⽐如data定义数据、methods中定义⽅法、computed中定义计算属性、watch中监听属性改变，也包括⽣命周期钩⼦。 弊端: 当我们实现某⼀个功能时，这个功能对应的代码逻辑会被拆分到各个属性中,当组件变得复杂，导致对应属性的列表也会增⻓，这可能会导致组件难以阅读和理解 35. Composition API和之Options API有什么区别? 1）在逻辑组织和逻辑复⽤⽅⾯，Composition API是优于Options API。 2）Composition API⼏乎是函数，会有更好的类型推断，对于TS的⽀持更友好。 3）Composition API对 tree-shaking 友好，代码也更容易压缩。 4）Composition API中⻅不到this的使⽤，减少了this指向不明的情况。 5）Composition API⽤起来稍微复杂⼀点，⽽Options API就⾮常简单、易于使⽤。 36. 说说Vue3中setup函数的作⽤？ 在Vue3中， setup()函数充当了组件编写Composition API的⼊⼝点。setup函数参数主要有两个参数： 1）第⼀个参数：props , ⽗组件传递过来的属性会被放到props对象中 2）第⼆个参数：context, 它⾥⾯包含三个属性： attrs：所有的⾮prop的attribute； slots：⽗组件传递过来的插槽； emit：当我们组件内部需要发出事件时会⽤到emit（因为我们不能访问this，所以不可以通过this.$emit发出事件） 作用： 可以在setup中可以定义响应式数据、⽅法、计算属性、侦听器等等。 可以通过setup的返回值来替代data选项，让数据可以直接在template中使⽤。 37.ref和reactive有什么区别？开发中如何选择？ ref和reactive都是响应式的API，都可以⽤来定义响应式的数据。 ref可以包裹任意数据类型，reactive只能包裹复杂数据类型，⽐如对象、数组。 ref返回⼀个ref对象，在script中取值需要通过value属性，但是在模板中使⽤会进⾏解包不需要调⽤value。 reactive包裹的是复杂数据类型，直接取⾥⾯的属性即可。 ref⼏乎可以应⽤在任何场景，⽽且包含reactive适合的场景; reactive的应⽤场景⽐较受限，第⼀：值⽐较固定，第⼆：值与值之间是有联系的。 开发中尽量选择ref 38. Composition API常⻅的⼏个函数与⽤法？ reactive：包裹复杂类型的值，将包裹的值加⼊响应式 computed：把⼀些复杂逻辑⽤computed进⾏包裹，如同Options API中的计算属性⼀样，computed会⾃动收集相关依赖，当依赖发⽣变化时，会⾃动进⾏更新 ⽣命周期：Vue3中想要在beforeCreate和created中做的事，直接在setup中做即可，Vue3的其他的⽣命周期函数都要在前⾯加⼀个on，然后需要在vue中主动引⼊ watch： 1）watch可以监听单个数据源，也可以监听多个数据源 2）watch是懒执⾏，第⼀次是不会执⾏的，除⾮你为其提供第三个参数中的immediate属性为true 3）watch只有等到监听的数据源发⽣了变化后，才会执⾏第⼆个参数（回调） 4）watch可以获取监听数据源的前后变化的值 5）侦听多个数据源的时候，第⼀个参数是数组类型 watchEﬀect： 1）watchEﬀect会⾃动收集依赖，收集的依赖是第⼀个参数，也就是回调函数中有哪些东⻄是加⼊响应式的 2）如果这个值加⼊了响应式就会被收集起来，当被收集的值发⽣了变化，就会重新执⾏这个回调函数 3）watchEﬀect第⼀次执⾏是在DOM挂载前执⾏的，所以如果你想在第⼀次执⾏时拿到DOM元素 4）需要传⼊第⼆个参数，第⼆个参数是⼀个对象，让其ﬂush属性的值为post即可 toRefs： 1）对reactive进⾏解构后就失去了响应式的效果，因为reactive返回的是⼀个Proxy对象 2）对Proxy对象进⾏解构，拿到的是纯净的值，所以没有了响应式的效果 3）如果想要对reactive进⾏解构，需要对其包裹⼀个toRefs 4）这么做相当于为reactive中的每⼀个值包裹了⼀个ref 39. Vue3中的watch和watchEﬀect有什么区别？ watch和watchEﬀect都⽤⽤来侦听响应式数据的变化，watch可以侦听指定的源，默认第⼀次不会执⾏，watchEﬀect虽不能指定侦听的源，但是会⾃动收集依赖，并默认会先执⾏⼀次。 watch： 1）watch可以监听单个数据源，也可以监听多个数据源 2）watch是懒执⾏，第⼀次是不会执⾏的，除⾮你为其提供第三个参数中的immediate属性为true watch只有等到监听的数据源发⽣了变化后，才会执⾏第⼆个参数（回调） watch可以获取监听数据源的前后变化的值 侦听多个数据源的时候，第⼀个参数是数组类型 watchEﬀect: 1)watchEﬀect会⾃动收集依赖，收集的依赖是第⼀个参数，也就是回调函数中有哪些东⻄是加⼊响应式的 2)如果这个值加⼊了响应式就会被收集起来，当被收集的值发⽣了变化，就会重新执⾏这个回调函数 3)watchEﬀect第⼀次执⾏是在DOM挂载前执⾏的，所以如果你想在第⼀次执⾏时拿到DOM元素 4)需要传⼊第⼆个参数，第⼆个参数是⼀个对象，让其ﬂush属性的值为post即可 40. 说说Vue3中script setup语法糖常⻅⽤法？ script setup 是在单⽂件组件中使⽤ Composition API 的编译时语法糖，相⽐与之前的setup函数写法，它具有更多的优势： 1）更少的样板内容，更简洁的代码。 2）能够使⽤纯 TypeScript 声明 props 和抛出事件。 3）更好的运⾏时性能 (其模板会被编译成与其同⼀作⽤域的渲染函数，没有任何的中间代理)。 4）更好的IDE类型推断性能 (减少语⾔服务器从代码中抽离类型的⼯作)。 script setup： 1）当使⽤ script setup 的时候，任何在 script setup 声明的顶层绑定都能在模板中直接使⽤ 2）声明的顶层绑定：包括变量，函数声明，以及 import 引⼊的内容 3）响应式数据需要通过ref、reactive来创建 4）在script setup中导⼊的组件可以直接使⽤ deﬁneProps： 1）在script setup语法糖中必须使⽤ deﬁneProps API来声明props，它具备完整的类型推断并且在&lt;script setup&gt; 中是直接可⽤的（不需要额外导⼊）。 deﬁneEmits： 1）在script setup语法糖中必须使⽤ deﬁneEmits API来声明 emits，它具备完整的类型推断并且在&lt;script setup&gt; 中是直接可⽤的（不需要额外导⼊）。 deﬁneExpose： 1）获取组件的实例可以通过ref来获取，接着组件挂载完成后可通过value拿到组件实例。 2）当拿到组件实例后，默认是不可以访问这个实例中的⽅法和属性，因为默认没暴露任何⽅法和属性。 3）因此在Vue3组件中可以⽤deﬁneExpose API来暴露⽅法和属性给外部访问。 4）deﬁneExpose 也是不需要导⼊，直接使⽤即可 ","link":"https://ixoxxoxi.github.io/post/vue2&3-31-40/"},{"title":"Vue2/3面试题(21-30)","content":"21.data选项为什么是⼀个函数⽽不是对象？ 根实例对象 data 可以是对象也可以是函数（根实例是单例），不会产生数据污染情况 组件实例对象 data 必须为函数，目的是为了防止多个组件实例对象之间共用一个 data，产生数据污染。采用函数的形式，initData 时会将其作为工厂函数都会返回全新 data 对象 22. Vue data 中某⼀个属性的值发⽣改变后，视图会⽴即同步执⾏、重新渲染吗？ 不会立即同步执行重新渲染。 Vue实现响应式并不是数据发生变化之后DOM立即变化，而是按一定的策略进行DOM的更新。Vue在更新DOM时是异步执行的。只要侦听到数据变化，Vue将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。 如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作是非常重要的。然后，在下一个的事件循环tick中，Vue刷新队列并执行实际（已去重的）工作。 23. 在 Vue. js开发环境下调⽤API接⼝，如何避免跨域 vue2--vue.config.js module.exports = { configureWebpack: { devServer: { proxy: { '/api': { target: '', // 在本地会创建一个虚拟服务端，然后发送请求的数据，并同时接收请求的数据，这样服务端和服务端进行数据的交互就不会有跨域问题 changeOrigin: true, ws: true // , // pathRewrite: { // '^/api': '/api' // // 替换target中的请求地址，也就是说以后你在请求http://api.jisuapi.com/XXXXX这个地址的时候直接写成/api即可 // } } } } } } vue3--vite.config.js export default defineConfig({ // ... server: { proxy: { &quot;/api&quot;: { target: &quot;&quot;, changeOrigin: true, }, }, }, // ... }) 24.v-if和v-for⼀起使⽤的弊端及解决办法 在vue2中： 当它们处于同一节点，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。 如果你的目的是有条件地跳过循环的执行，那么可以将 v-if 置于外层元素 (或 &lt;template&gt;) 上。 在vue3中： 它们同时存在于一个节点上时，v-if 比 v-for 的优先级更高。 在外新包装一层&lt;template&gt;再在其上使用 v-for 可以解决这个问题 25. 谈谈你对 keep-alive 的了解？ &lt;keep-alive&gt; 是一个内置组件，它的功能是在多个组件间动态切换时缓存被移除的组件实例,主要用于保留组件状态或避免重新渲染。 提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高； 对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。 26. 什么是侦听器？有什么用？ Vue提供了一种更通用的方式来观察和响应Vue实列上的数据变动：侦听属性，当属性发生改变时，自动触发属性对应的侦听器。 27. 侦听器能不能监听数组/对象的变化？ 可以，但默认不监听深层,需要配置deep:true 28. 如何监听一个对象中的某个属性变化？ deep:true, 推荐 'obj.key'这种监听写法 29. 侦听器为什么默认不支持深度监听？（性能优化） 深度侦听需要遍历被侦听对象中的所有嵌套的属性，当用于大型数据结构时，开销很大。因此只在必要时才使用它，并且要留意性能消耗。 30. 什么是组件化？你怎么理解组件化？ 1.组件是独立和可复用的代码组织单元。组件系统是Vue核心特性之一，它使开发者使用小型、独立和通常可复用的组件构建大型应用； 2.组件化开发能大幅提高应用开发效率、测试性、复用性等； 3.组件使用按分类有：页面组件、业务组件、通用组件； 4.vue的组件是基于配置的，我们通常编写的组件是组件配置而非组件，框架后续会生成其构造函数，它们基于VueComponent，扩展于Vue； 5.vue中常见组件化技术有：属性prop，自定义事件，插槽等，它们主要用于组件通信、扩展等；6合理的划分组件，有助于提升应用性能； 6.组件应该是高内聚、低耦合的； 7.遵循单向数据流的原则 ","link":"https://ixoxxoxi.github.io/post/vue2&3-21-30/"},{"title":"Vue2/3面试题(11-20)","content":"11. 谈一谈Vue中组件通信？ 1)父子组件通信：父传子使用自定义属性（props），子传父使用自定义事件（$emit()）。 2)状态提升：当兄弟组件之间需要共享数据时，我们通常的做法是把这个数据定义它们的共同的父组件中，再通过自定义属性实现数据共享。 3)provide/inject：这是在组件树中，自上而下的一种数据通信方案，也就是说只能父级组件中向后代组件传递。需要注意的是，当provide提供动态数据（声明式变量）时，动态数据发生变化，后代组件们不会自动更新。这是为什么呢？你自己从生命周期流程的角度去思考。 4)ref通信：ref是Vue内置的一个属性，每一个HTML元素或组件都有这个属性；ref作用在HTML元素上得到DOM实例，ref作用在组件上得到组件实例。使用ref访问组件实例，进一步可以访问组件中的数据和方法。（说明：ref是一种快速的DOM的访问方式，当然ref也可作用在组件上得到组件实例。这些ref得到的DOM实例或组件实例，使用this.$refs来访问它们。ref尽量少用，除非某些难搞的需求。） 5)插槽通信：借助&amp;lt;slot&gt;组件实现从子组件向父组件传递数据，借助this.$slots访问父组件中的插槽实例。(在自定义组件中使用this.$slots访问父组件给的插槽实例；在父组件插槽中使用#default='scoped'访问子组件&amp;lt;slot&gt;回传的数据。这种通信在组件库中、工作中，非常常见！) 6)$parent/$children：借助$parent/$children可以实现，在任一组件中访问组件树中的其它任意组件实例，可以做到在组件中随意穿梭。($parent表示的是当前组件的父组件实例，$children表示的是当前组件的子组件们。) 7)$attrs/$listeners：借助$attrs可访问父组件传递过来的自定义属性（除了class和style外），借助$listenrs可以访问父组件给的自定义事件。在某些场景下，$attrs/$listeners可以替代props/$emit()这种通用的通信方案。 8)事件总线：借助于Vue内置的事件系统（$on/$emit/$off/$once）实现“订阅-发布”式的通信，这种通信方式是一种与组件层级无关的“一对多”的通信。（工作中很少用，一些特殊的Vue项目才用得到事件总线。） 9)Vuex通信：这是Vue架构中终极的通信方案，也是Vue架构中用的最多的一种通信方案。 12. Vue中逻辑复用技巧有哪些？ 组件：复用UI+逻辑 混入 自定义指令 渲染函数&amp;JSX 插件 过滤器 V3中的自定义hook 13. 你项目的鉴权怎么做的？你这个管理系统的权限怎么设计的？ 我们之前的公司中小公司，做的项目，大概有30个左右的模块，所以权限这一块，就前端去处理的。我们处理的流程大致是这样的： 前端登录换取token，在导航守卫中，实现权限设计，首先判断有没有token，没有token，直接跳到登录页面。有token会进一步判断vuex中有没有用户信息。如果没有用户信息，拿着token，调用接口获取用户信息，用户信息中保存了最重要的字段，就是角色，有了角色后，通过算法生成当前用户可访问的动态路由规则（算法大至是使用后端返回的角色和路由元信息中的角色进行对比，得到可以访问的动态路由规则），有了动态访问的路由规则，再通过addRoutes方法，把得到的动态访问的路由规则添加到路由系统。 14. 简述Vuex的工作流程？ 背官方的图 5大概念，4个map，3个原则。 5大概念： 创建store时要用的五个概念（state/getters/mutations/actions/modules） state: {} 用于定义可被组件共享数据，是具有响应式的；在组件中使用this.$store.state来访问它们。 getters: {fn} 用于计算state，相当于Vue的计算属性，当state发生变化时getters方法自动自动重新计算；在组件中使用this.$store.getters来访问它们。 mutations: {fn} 专门用于修改state的，所以mutations方法是这样fn(state,payload)定义的；mutations方法在actions中或组件中使用，使用$store.commit('mutations方法',payload) actions: {fn} 专门用于调接口的，所以actions方法是这样fn(store,payload)定义的；在组件中使用this.$store.dispatch('actions方法', payload)。 modules: {子store} 是一个Vuex架构层面的概念，用于拆分子store。大家在拆分子store务必在子store中使用namespaced:true开启命名空间。 4个map: mapState/mapGetters，必须写在computed计算属性中，用于访问state/getters数据。映射进来后，就可以用this来访问这些数据了。 mapActions/mapMutations 必须写在methods选项中，用于访问mutations/actions方法。映射进来后，可以用this调用这些方法。 它们的语法是相同的：map*('命名空间', ['k1', 'k2']) 3个原则： 原则1：只要使用Vuex一定要拆分store，拆分store后在根store上不要再使用state/mutations/actions。 原则2：在子store务必开启命名空间namespaced:true。 原则3：在组件中尽可能不要使用$store，建议使用四个map*方法。 15. 说说你对 SPA 单⻚⾯的理解，它的优缺点分别是什么？ SPA就是只有一张Web页面的应用，是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。 浏览器一开始会加载必需的HTML、CSS和JavaScript，所有的操作都在这张页面上完成，都由JavaScript来控制。因此，对单页应用来说模块化的开发和设计显得相当重要。 优点： 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染； 基于上面这一点，SPA相对对服务器压力小； 前后端职责分离，结构清晰，前端进行交互逻辑，后端进行数据处理； 缺点： 初次加载时耗时多：为实现单页web应用功能及显示效果，需要在加载页面的时候将js,css统一加载，部分按需加载； 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理； SEO难度较大：由于所有的内容都在一个页面中动态替换显示，所以在SEO上其有着天然的弱势。 16.v-show 与 v-if 有什么区别？ 手段：v-if是通过控制dom节点的存在与否来控制元素的显隐；v-show是通过设置DOM元素的display样式，block为显示，none为隐藏； 编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换； 编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译（编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载); v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留； 性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗 17. 数组中的哪些⽅法会触发视图的更新？ push() pop() shift() unshift() splice() sort() reverse() 18. Vue中v-for的key 有什么作⽤？ key是特殊的attribute,主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。 19.computed和method有什么区别？ 调用方式不同。computed 直接以对象属性方式调用，不需要加括号，而 methods 必须要函数执行才可以得到结果。 绑定方式不同。methods 与 compute 纯 get 方式都是单向绑定，不可以更改输入框中的值。compute 的 get 与 set 方式是真正的双向绑定。 是否存在缓存。methods 没有缓存，调用相同的值计算还是会重新计算。competed 有缓存，在值不变的情况下不会再次计算，而是直接使用缓存中的值。 20. 什么是双向绑定？v-model的本质是什么？ 从界面的操作能实时反映到数据，数据的变更能实时展现到界面，即是数据的双向绑定。 v-model的本质是语法糖，如对于input框来说可看作v-bind:value和v-on:input的语法糖。 ","link":"https://ixoxxoxi.github.io/post/vue2&3-11-20/"},{"title":"Vue2/3面试题(1-10)","content":"1. 你怎么理解指令？工作中你封装过自定义指令吗？举一些例子 指令本质上是对dom的操作，vue封装这些指令就是为了我们更为合理符合规范的操作dom，避免DOM滥操作。 v-permission指令 有权限则显示按钮等模块，没有权限则不显示 &lt;div id=&quot;app&quot;&gt; &lt;button v-permission=&quot;'admin'&quot;&gt;管理员-按钮&lt;/button&gt; &lt;button v-permission=&quot;'editor'&quot;&gt;作者-按钮&lt;/button&gt; &lt;!-- 游客按钮不显示 --&gt; &lt;button v-permission=&quot;'guest'&quot;&gt;游客-按钮&lt;/button&gt; &lt;button v-permission=&quot;user.role&quot;&gt;user-按钮&lt;/button&gt; &lt;/div&gt; function checkArray(role) { let arr = ['admin', 'editor']; let index = arr.indexOf(role); return index &gt; -1 ? true : false; } Vue.directive('permission', { inserted: function (el, binding) { if (!(binding.value &amp;&amp; checkArray(binding.value))) { console.log(binding.value + '用户组没有权限使用该功能'); el.parentNode &amp;&amp; el.parentNode.removeChild(el) } } }) let vm = new Vue({ el: '#app', data() { return { user: { id: '001', name: 'wangcai', age: 18, role: 'admin' } } }, methods: { } }) v-draggable 拖拽指令 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #app { width: 100%; height: 500px; outline: 1px solid blue; position: relative; } .drag { width: 50px; height: 50px; background-color: blue; position: absolute; } &lt;/style&gt; &lt;script src=&quot;./lib/vue@2.7.10.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;drag&quot; v-draggable&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; Vue.directive('draggable', { inserted: function (el) { el.style.cursor = 'move'; el.onmousedown = function (e) { let disx = e.pageX - el.offsetLeft; let disy = e.pageY - el.offsetTop; document.onmousemove = function (e) { let x = e.pageX - disx; let y = e.pageY - disy; let maxX = document.body.clientWidth - parseInt(window.getComputedStyle(el).width); let maxY = document.body.clientHeight - parseInt(window.getComputedStyle(el).height); if (x &lt; 0) { x = 0 } else if (x &gt; maxX) { x = maxX } if (y &lt; 0) { y = 0 } else if (y &gt; maxY) { y = maxY } el.style.left = x + 'px'; el.style.top = y + 'px'; } document.onmouseup = function () { document.onmousemove = document.onmouseup = null } } } }) let vm = new Vue({ el: '#app', data() { return { } }, methods: { } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 2. 计算属性能不能绑定在v-model上？ 计算属性可以有setter，所以可以使用在v-model上面。 3. 侦听器能监听哪些变量变化？ 能够监听data、计算属性、vuex数据、$route等，凡是那些带有__ob__变量都能被监听到。 4. 说一下Vue的响应式原理？(你是如何理解MVVM的) 回答版本一： 当vue组件被创建时，在生命周期的第一阶段，Vue使用Object.defineProperty()对data选项进行遍历劫持并添加get/set钩子；在生命周期第二阶段，指令第一次与声明式变量touch时，发生依赖收集，再调用当前组件的watcher第一次更新DOM，DOM视图就显示出来了。当声明式变量发生变化时，vue再次通知Watcher更新视图，这就是响应式（原理） 回答版本二： 当new Vue时，Vue源码中有一个Observer，会对data中所有的数据进行劫持，把data中的数据处理成响应式，每处理一个响应式数据，都有一个Dep与之对应。同时编译模板，编译模板时会找到小胡子语法和指令，处理小胡子语法和指令时，会创建出一个个的Watcher，这些Watcher会存储到对应的Dep中，这个过程叫依赖收集，同时调用对应的Updater，完成对应的页面的初始化。当数据发生变化时，在Observer的setter中会监听到，数据变化，就通知Dep中的Watcher更新视图，每个Watcher都绑定了更新视图的回调函数。 5. 你工作中有没有封装比较好的组件？ 一个样式丰富的button组件 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .mybtn { display: inline-block; line-height: 1; white-space: nowrap; cursor: pointer; background: #fff; border: 1px solid #dcdfe6; color: #606266; text-align: center; box-sizing: border-box; outline: none; margin: 0; transition: .1s; font-weight: 500; padding: 12px 20px; font-size: 14px; border-radius: 4px; } .primary { color: #fff; background-color: #409eff; border-color: #409eff; } .success { color: #fff; background-color: #67c23a; border-color: #67c23a; } .info { color: #fff; background-color: #909399; border-color: #909399; } .warning { color: #fff; background-color: #e6a23c; border-color: #e6a23c; } .danger { color: #fff; background-color: #f56c6c; border-color: #f56c6c; } .is-round { border-radius: 20px; padding: 12px 23px; } .is-plain { color: #409eff; background: #ecf5ff; border-color: #b3d8ff; } &lt;/style&gt; &lt;script src=&quot;./lib/vue@2.7.10.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;mybtn text=&quot;默认按钮&quot; type=&quot;default&quot;&gt;&lt;/mybtn&gt; &lt;mybtn text=&quot;主要按钮&quot; type=&quot;primary&quot;&gt;&lt;/mybtn&gt; &lt;mybtn text=&quot;成功按钮&quot; type=&quot;success&quot;&gt;&lt;/mybtn&gt; &lt;mybtn text=&quot;信息按钮&quot; type=&quot;info&quot;&gt;&lt;/mybtn&gt; &lt;mybtn text=&quot;警告按钮&quot; type=&quot;warning&quot;&gt;&lt;/mybtn&gt; &lt;mybtn text=&quot;危险按钮&quot; type=&quot;danger&quot;&gt;&lt;/mybtn&gt; &lt;hr&gt; &lt;mybtn text=&quot;朴素按钮&quot; plain type=&quot;default&quot;&gt;&lt;/mybtn&gt; &lt;mybtn text=&quot;主要按钮&quot; plain type=&quot;primary&quot;&gt;&lt;/mybtn&gt; &lt;mybtn text=&quot;成功按钮&quot; plain type=&quot;success&quot;&gt;&lt;/mybtn&gt; &lt;mybtn text=&quot;信息按钮&quot; plain type=&quot;info&quot;&gt;&lt;/mybtn&gt; &lt;mybtn text=&quot;警告按钮&quot; plain type=&quot;warning&quot;&gt;&lt;/mybtn&gt; &lt;mybtn text=&quot;危险按钮&quot; plain type=&quot;danger&quot;&gt;&lt;/mybtn&gt; &lt;hr&gt; &lt;mybtn text=&quot;圆角按钮&quot; round type=&quot;default&quot;&gt;&lt;/mybtn&gt; &lt;mybtn text=&quot;主要按钮&quot; round type=&quot;primary&quot;&gt;&lt;/mybtn&gt; &lt;mybtn text=&quot;成功按钮&quot; round type=&quot;success&quot;&gt;&lt;/mybtn&gt; &lt;mybtn text=&quot;信息按钮&quot; round type=&quot;info&quot;&gt;&lt;/mybtn&gt; &lt;mybtn text=&quot;警告按钮&quot; round type=&quot;warning&quot;&gt;&lt;/mybtn&gt; &lt;mybtn text=&quot;危险按钮&quot; round type=&quot;danger&quot;&gt;&lt;/mybtn&gt; &lt;/div&gt; &lt;script id=&quot;mybutton&quot; type=&quot;x-template&quot;&gt; &lt;button v-text=&quot;text&quot; class=&quot;mybtn&quot; :class=&quot;[btnColor,isPlain,isRound]&quot;&gt;&lt;/button&gt; &lt;/script&gt; &lt;script&gt; Vue.component(&quot;mybtn&quot;, { template: &quot;#mybutton&quot;, props: { text: { type: String, default: '默认内容' }, type: { type: String, default: 'primary' }, round: { type: Boolean, default: false }, plain: { type: Boolean, default: false } }, computed: { btnColor() { switch (this.type) { case 'primary': return 'primary' break; case 'success': return 'success' break; case 'info': return 'info' break; case 'warning': return 'warning' break; case 'danger': return 'danger' break; default: return '' } }, isRound() { return this.round ? 'is-round' : '' }, isPlain() { return this.plain ? 'is-plain' : '' } } }); let vm = new Vue({ el: &quot;#app&quot;, data() { return {}; }, methods: {}, }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 6. 说一下Vue的生命周期（展开说，不仅仅是那几个钩子）？ Vue的生命周期指的是组件从“生”到“死”的全过程，一共分四个阶段，不同阶段有不同的钩子函数： 创建阶段：beforeCreate、created 挂载阶段：beforeMount、mounted 更新阶段：beforeUpdate、updated 销毁阶段：beforeDestroy、destroyed 与动态组件有关的两个特殊的钩：activated(激活)、deactivated(休眠) 与组件异常捕获有关的一个钩子：errorCaptured 在beforeCreate之前会声明methods中的方法和声明生命周期钩子函数，这个钩子函数我们用的并不多 在created之前会注入一些数据，初始化响应式系统，我们通常在这个钩子函数中调接口，获取路由参数等 在beforeMount之前会通过el $meount template找模板，会把模块变成render函数 调用render函数创建虚拟DOM，虚拟DOM转化成真实DOM，进行挂载，通常这个钩子函数我们也用不到 在mounted时，已表示真实DOM已挂载完毕，我们在这个钩子中通常调接口，开定时器，DOM操作，建立websocket连接 实例化echarts实例等。 当数据变化时，会触发beforeUpdate钩子，这个钩子通常也用不到。 在updated之前，要生成新的虚拟DOM，新的虚拟DOM和老的虚拟DOM进行对比，会执行patch运算，diff算法，找到两个虚拟DOM的最小差异，找到后，进行异步更新，key的目的就是最快找到最小差异，这个钩子也不常用，但是有点类似于watch侦听器或类似于$nextTick()，我们不能在这个钩子中更新数据，会导致死循环。 当我们手动调用$destory()或路由切换时，会调用beforeDestroy这个钩子函数，我们可以在这个钩子函数中清空定时器，解除事件绑定，清除缓存... 当组件销毁时，就会移除当前组件的watcher，DOM就无法再更新，移除所有子组件，移除事件监听器，响应式系统就会失效，组件就死亡了，这个钩子函数我们用的也不多。 7. 虚拟DOM存在的价值点在哪里？ 把DOM更新粒度降到最低，规避人为DOM滥操作，提升性能。配合DIFF算法，可以让页面性能有质的提升。 8. Vue有哪些内置组件？Vue中实现条件渲染渲染有哪些办法？ 五个内置组件(slot,transition,component,keep-alive) 条件渲染: v-if v-show 动态组件 9. 你有封装过Vue插件？怎么封装的？封装过什么？ 在Vue生态中，除了Vue本身，其它所有与Vue相关的第三方包，都是插件，都得以插件的方式进行集成。 作用：是一种更加高级的代码复用技术，可以以插件的方式为我们提供可复用的组件、混入、指令、过滤器、原型链API。 两种写法： 第一种写法： const Plugin = { install (Vue) { } } 第二种写法： const Plugin = function (Vue) {} 在项目中我之前二次封装axios，把它封装成一个插件，参考： https://juejin.cn/post/6844903599764406280 封装右键菜单插件： https://juejin.cn/post/6906788973981466637 10. 谈一谈你对 Vue.nextTick() 的理解？有什么用？ 数据变化，进行set操作，代码确实是同步的，但是set行为是异步的；set操作修改声明变量，触发re-render生成新的虚拟DOM，进一步执行diff运算，找到脏节点集合，交给Vue背后的更新队列去执行循环更新。在更新队列中每一个更新任务都是一个更新单元，nextTick表示下一个更新单元（更新周期）。 我们set操作data（更新DOM），你希望访问这个DOM的最新状态时，使用this.$nextTick(handler)。 ","link":"https://ixoxxoxi.github.io/post/vue2&3-1-10/"}]}