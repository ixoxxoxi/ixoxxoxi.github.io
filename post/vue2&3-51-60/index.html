<html>
<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>Vue2/3面试题(51-60) | Learning Notes</title>

<link rel="shortcut icon" href="https://ixoxxoxi.github.io/favicon.ico?v=1675607442775">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://ixoxxoxi.github.io/styles/main.css">
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css"> -->

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages//dart.min.js"></script>

<!-- <script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script> -->
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
    
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <a class="navbar-brand" href="/">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            Learning Notes
        </div>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation" id="changeNavbar">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="/" class="menu gt-a-link">
                    首页
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/archives" class="menu gt-a-link">
                    归档
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tags" class="menu gt-a-link">
                    标签
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/post/about" class="menu gt-a-link">
                    关于
                </a>
                
            </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1675607442775"
                action="/search/">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = () => {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else {
            element.style.display = 'none';
        }
    }
</script>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    Vue2/3面试题(51-60)
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2022-12-31 ·
                    </time>
                    
                        <a href="https://ixoxxoxi.github.io/tag/vue/" class="post-tags">
                            # Vue2/3
                        </a>
                    
                </div>
                <div class="post-content">
                    <h3 id="51-在vue中实现条件渲染渲染有哪些办法">51. 在Vue中实现条件渲染渲染有哪些办法？</h3>
<!-- more -->
<pre><code class="language-vue">v-if v-else-if v-else
v-show
&lt;component :is=&quot;componentId&quot;&gt;&lt;/component&gt;
</code></pre>
<h3 id="52-路由跳转时如何传递数据">52. 路由跳转时如何传递数据？</h3>
<p>动态路由：</p>
<ul>
<li>1）<code>path: /user/:id</code></li>
<li>2）获取动态路由的值的⽅式如下：</li>
<li>3）在<code>template</code>中，直接通过 <code>$route.params</code>获取值</li>
<li>4）在<code>created</code>中，通过 <code>this.$route.params</code>获取值</li>
<li>5）在<code>setup</code>中，使⽤ <code>vue-router</code> 库提供的⼀个<code>hook</code> <code>useRoute</code>（该Hook会返回⼀个Route对象，对象中保存着当前路由相关的值）</li>
</ul>
<p>query参数:</p>
<ul>
<li>1）通过<code>query</code>的⽅式来传递参数</li>
<li>2）在界⾯中通过 <code>$route.query</code> 来获取参数</li>
<li>3）在<code>created</code>中，通过 <code>this.$route.query</code> 获取值</li>
<li>4）在<code>setup</code>，使⽤ <code>vue-router</code> 库提供的⼀个<code>hook</code> <code>useRoute</code> 来获取</li>
</ul>
<h3 id="53-计算属性有什么作用两大作用">53. 计算属性有什么作用？（两大作用）</h3>
<blockquote>
<p>Tips:可以研究一下，计算属性的实现原理。找资料，找视频，回答：我之前看过vue的源码，它的计算属性是xxxx实现的。</p>
</blockquote>
<ul>
<li>
<p>作用1：当指令的表达式比较复杂时，我们建议使用计算属性来优化，提升视图模板中代码的可阅读性、可维护性。</p>
</li>
<li>
<p>作用2：用于缓存一个复杂的运算，避免组件更新时产生没有必要的性能损耗。计算属性本质上是一个函数，Vue会分析函数体中使用到了哪些声明式变量，有且仅有这些声明式变量发生变化时，计算属性才会重新执行。</p>
</li>
</ul>
<h3 id="54-什么是路由守卫路由守卫有什么作用">54. 什么是路由守卫？路由守卫有什么作⽤？</h3>
<p><code>vue-router</code> 提供的路由(导航)守卫主要⽤来通过跳转或取消的⽅式守卫导航。有很多种⽅式植⼊路由导航中：全局的，单个路由独享的，或者组件级的。</p>
<h4 id="全局导航钩子">全局导航钩⼦</h4>
<ul>
<li>全局前置守卫</li>
</ul>
<pre><code class="language-js">const router = new VueRouter({ ... })

router.beforeEach((to, from, next) =&gt; {
  // ...
})
</code></pre>
<ul>
<li>
<p>全局解析守卫</p>
<p>在 2.5.0+ 你可以用 <code>router.beforeResolve</code> 注册一个全局守卫。这和 <code>router.beforeEach</code> 类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。</p>
</li>
<li>
<p>全局后置钩子</p>
</li>
</ul>
<pre><code class="language-js">router.afterEach((to, from) =&gt; {
  // ...
})
</code></pre>
<ul>
<li>路由独享的守卫</li>
</ul>
<p>在路由配置上直接定义 <code>beforeEnter</code> 守卫</p>
<pre><code class="language-js">const router = new VueRouter({
  routes: [
    {
      path: '/foo',
      component: Foo,
      beforeEnter: (to, from, next) =&gt; {
        // ...
      }
    }
  ]
})
</code></pre>
<blockquote>
<p>这些守卫与全局前置守卫的方法参数是一样的</p>
</blockquote>
<h4 id="组件内的钩子">组件内的钩⼦</h4>
<pre><code class="language-js">const Foo = {
  template: `...`,
  beforeRouteEnter(to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 因为当守卫执行前，组件实例还没被创建
  },
  beforeRouteUpdate(to, from, next) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
  },
  beforeRouteLeave(to, from, next) {
    // 导航离开该组件的对应路由时调用
    // 可以访问组件实例 `this`
  }
}
</code></pre>
<p><code>beforeRouteEnter</code> 守卫 不能 访问 <code>this</code>，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建。</p>
<p>不过，你可以通过传一个回调给 <code>next</code>来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。</p>
<pre><code class="language-js">beforeRouteEnter (to, from, next) {
  next(vm =&gt; {
    // 通过 `vm` 访问组件实例
  })
}
</code></pre>
<p>注意 <code>beforeRouteEnter</code> 是支持给 <code>next</code> 传递回调的唯一守卫。对于 <code>beforeRouteUpdate</code> 和 <code>beforeRouteLeave</code> 来说，<code>this</code> 已经可用了，所以不支持传递回调，因为没有必要了。</p>
<pre><code class="language-js">beforeRouteUpdate (to, from, next) {
  // just use `this`
  this.name = to.params.name
  next()
}
</code></pre>
<p>这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 <code>next(false)</code> 来取消。</p>
<pre><code class="language-js">beforeRouteLeave (to, from, next) {
  const answer = window.confirm('Do you really want to leave? you have unsaved changes!')
  if (answer) {
    next()
  } else {
    next(false)
  }
}
</code></pre>
<h4 id="单独路由独享组件">单独路由独享组件</h4>
<pre><code class="language-js">1) beforeEnter: (to, from, next)
2) afterEach(to,from)
3)...
</code></pre>
<h4 id="路由守卫作用">路由守卫作⽤</h4>
<ul>
<li>1)可以在进⼊路由之前进⾏某些判断，⽐如，检查token是否存在来判断⽤户是否已经登录。</li>
<li>2)可以在路由守卫中进⾏⻚⾯的权限判断，⽐如，判断某个⽤户是否拥有该⻚⾯的权限。</li>
<li>3)也可以⽤来记录⻚⾯的某些信息，⽐如，记录⻚⾯的滚动信息等等。</li>
</ul>
<h4 id="完整的导航解析流程">完整的导航解析流程</h4>
<ol>
<li>导航被触发。</li>
<li>在失活的组件里调用 <code>beforeRouteLeave</code> 守卫。</li>
<li>调用全局的 <code>beforeEach</code> 守卫。</li>
<li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2.2+)。</li>
<li>在路由配置里调用 <code>beforeEnter</code>。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li>
<li>调用全局的 <code>beforeResolve</code> 守卫 (2.5+)。</li>
<li>导航被确认。</li>
<li>调用全局的 <code>afterEach</code> 钩子。</li>
<li>触发 <code>DOM</code> 更新。<br>
12 调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li>
</ol>
<h3 id="55route和router的区别">55.route和router的区别</h3>
<p><code>route</code>是路由信息对象，在Vue3中通过 <code>useRoute</code> 来获取。</p>
<ul>
<li>1)包括了<code>path</code>，<code>params</code>，<code>hash</code>，<code>query</code>，<code>fullPath</code>，<code>matched</code>，<code>name</code>等路由信息参数。</li>
</ul>
<p>router是路由实例”对象，在Vue3中通过 <code>useRouter</code> 来获取。</p>
<ul>
<li>1)包括了路由跳转⽅法、钩⼦函数等，⽐如：<code>push</code>、<code>go</code>、<code>back</code>、<code>addRouter</code>、<code>beforeEnter</code>等。</li>
</ul>
<h3 id="56vue-中怎么阻止冒泡怎么阻止默认事件怎么监听键盘enter键">56.vue 中怎么阻止冒泡？怎么阻止默认事件？怎么监听键盘enter键？</h3>
<p>阻止冒泡和默认事件：</p>
<ul>
<li>1）通过事件对象</li>
<li>2）事件事件修饰符</li>
</ul>
<p>监听键盘enter键：</p>
<ul>
<li>1）通过事件对象</li>
<li>2）通过按键修改符</li>
</ul>
<pre><code class="language-html">&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;
&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;
</code></pre>
<p>其他情况(官网示例)：</p>
<pre><code class="language-html">&lt;!-- 阻止单击事件继续传播 --&gt;
&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;

&lt;!-- 提交事件不再重载页面 --&gt;
&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;

&lt;!-- 修饰符可以串联 --&gt;
&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;

&lt;!-- 只有修饰符 --&gt;
&lt;form v-on:submit.prevent&gt;&lt;/form&gt;

&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;
&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;
&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;

&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;
&lt;!-- 即事件不是从内部元素触发的 --&gt;
&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;

&lt;!-- 点击事件将只会触发一次 --&gt;
&lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt;

&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;
&lt;!-- 而不会等待 `onScroll` 完成  --&gt;
&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;
&lt;div v-on:scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt;

&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;
&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;

&lt;!-- 你可以直接将 KeyboardEvent.key 暴露的任意有效按键名转换为 kebab-case 来作为修饰符 --&gt;
&lt;input v-on:keyup.page-down=&quot;onPageDown&quot;&gt;

&lt;!-- .exact 修饰符允许你控制由精确的系统修饰符组合触发的事件 --&gt;
&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;
&lt;button v-on:click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;

&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;
&lt;button v-on:click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;

&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;
&lt;button v-on:click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt;
</code></pre>
<h3 id="57-什么是状态管理什么是单项数据流">57. 什么是状态管理？什么是单项数据流？</h3>
<p>在开发中，应⽤程序是需要处理各种各样的数据，这些数据需要保存在应⽤程序中的某⼀个位置，对于这些数据的管理就称之为是 状态管理。以前我们是如何管理应⽤程序的状态？</p>
<ul>
<li>1）在Vue开发中，我们使⽤组件化的开发⽅式。⽽在组件中我们定义的data或在setup中返回的数据，这些数据我们称之为状态（<code>State</code>）。</li>
<li>2）在模块template中我们可以使⽤这些数据，模块最终会被渲染成DOM，我们称之为View。</li>
<li>3）在模块中我们会产⽣⼀些⾏为事件，处理这些⾏为事件时，有可能会修改<code>State</code>，这些⾏为事件我们称之为<code>Actions</code>。</li>
</ul>
<p>其实Vue组件内部的数据是以单向数据流的形式来管理数据的。<br>
例如，组件的数据定义在<code>State</code>中，接着在<code>View</code>层使⽤<code>State</code>中的数据，然后<code>View</code>层会产⽣⼀些事件<code>Actions</code>，⽽这些<code>Actions</code>可能会修改<code>State</code>的数据，这就是⼀个单项数据流的概念。</p>
<h3 id="58-什么是vuex你使用过-vuex-吗">58. 什么是Vuex？你使⽤过 Vuex 吗？</h3>
<p><code>vuex</code> 是⼀个专为 <code>Vue.js</code> 应⽤程序开发的状态管理模式。每⼀个 <code>Vuex</code> 应⽤的核⼼就是 <code>store</code>（仓库）。“<code>store</code>” 基本上就是⼀个容器，它包含着你的应⽤中⼤部分的状态 ( <code>state</code> )。</p>
<ul>
<li>
<p>1）<code>Vuex</code> 的状态存储是响应式的。</p>
<p>当 <code>Vue</code> 组件从 <code>store</code> 中读取状态的时候，若 <code>store</code> 中的状态发⽣变化，那么相应的组件也会相应地得到⾼效更新。</p>
</li>
<li>
<p>2)改变 store 中的状态的唯⼀途径就是显式地提交 (commit) mutation。这样使得我们可以⽅便地跟踪每⼀个状态的变化。</p>
</li>
</ul>
<p>Vuex包括⼀下⼏个核⼼模块：</p>
<ul>
<li>1)<code>State</code>：定义了应⽤状态的数据结构，可以在这⾥设置默认的初始状态。</li>
<li>2)<code>Getter</code>：允许组件从 <code>Store</code> 中获取数据，<code>mapGetters</code> 辅助函数仅仅是将 <code>store</code> 中的 <code>getter</code> 映射到计算属性。</li>
<li>3)<code>Mutation</code>：是唯⼀更改 <code>store</code> 中状态的⽅法，且必须是同步函数。</li>
<li>4)<code>Action</code>：⽤于提交 <code>mutation</code>，⽽不是直接变更状态，可以包含任意异步操作。</li>
<li>5)<code>Module</code>：允许将单⼀的 <code>Store</code> 拆分为多个 <code>store</code> 且同时保存在单⼀的状态树中。</li>
</ul>
<h3 id="59v-model-有哪些修饰符">59.v-model 有哪些修饰符？</h3>
<ul>
<li><code>.trim</code></li>
<li><code>.lazy</code></li>
<li><code>.number</code></li>
</ul>
<p><code>v-model</code> 在内部为不同的输入元素使用不同的 <code>property </code>并抛出不同的事件：</p>
<ul>
<li><code>text</code> 和 <code>textarea</code> 元素使用 <code>value property</code> 和 <code>input</code> 事件；</li>
<li><code>checkbox</code> 和 <code>radio</code> 使用 <code>checked property</code> 和<code> change</code> 事件；</li>
<li><code>select</code> 字段将 <code>value</code> 作为 <code>prop</code> 并将 <code>change</code> 作为事件。</li>
</ul>
<h3 id="60-vue中怎么做动画">60. Vue中怎么做动画？</h3>
<ol>
<li>内置组件transition，使用那6个类名编写自定义动画</li>
</ol>
<ul>
<li>
<p><code>enter-class</code></p>
</li>
<li>
<p><code>enter-active-class</code></p>
</li>
<li>
<p><code>enter-to-class</code></p>
</li>
<li>
<p><code>leave-class</code></p>
</li>
<li>
<p><code>leave-active-class</code></p>
</li>
<li>
<p><code>leave-to-class</code></p>
<ol>
<li>
<p><code>v-enter</code>：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。</p>
</li>
<li>
<p><code>v-enter-active</code>：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。</p>
</li>
<li>
<p><code>v-enter-to</code>：<strong>2.1.8 版及以上</strong>定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 <code>v-enter</code> 被移除)，在过渡/动画完成之后移除。</p>
</li>
<li>
<p><code>v-leave</code>：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。</p>
</li>
<li>
<p><code>v-leave-active</code>：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。</p>
</li>
<li>
<p><code>v-leave-to</code>：<strong>2.1.8 版及以上</strong>定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 <code>v-leave</code> 被删除)，在过渡/动画完成之后移除。<br>
<img src="https://v2.cn.vuejs.org/images/transition.png" alt="" loading="lazy"></p>
</li>
</ol>
</li>
</ul>
<ol start="2">
<li>使用animate.css第三方动画</li>
</ol>
<p>示例：</p>
<pre><code class="language-html">&lt;link href=&quot;https://cdn.jsdelivr.net/npm/animate.css@3.5.1&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;

&lt;div id=&quot;example-3&quot;&gt;
  &lt;button @click=&quot;show = !show&quot;&gt;
    Toggle render
  &lt;/button&gt;
  &lt;transition
    name=&quot;custom-classes-transition&quot;
    enter-active-class=&quot;animated tada&quot;
    leave-active-class=&quot;animated bounceOutRight&quot;
  &gt;
    &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt;
  &lt;/transition&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">new Vue({
  el: '#example-3',
  data: {
    show: true
  }
})
</code></pre>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://ixoxxoxi.github.io/post/vue2&amp;3-41-50/" class="post-title gt-a-link">
                    Vue2/3面试题(41-50)
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">这个人很懒 什么也不想说</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Copyright ©2022 |<a href="https://ixoxxoxi.github.io/" target="_blank">Learning Notes</a>| All Rights Reserved.
    </div>
    <div>
        Theme <a href="https://github.com/imhanjie/gridea-theme-pure" target="_blank">Pure</a>, Powered by <a
                href="https://gridea.dev" target="_blank">Gridea</a> | <a href="https://ixoxxoxi.github.io/atom.xml" target="_blank">RSS</a>
    </div>
</div>

<script>
  hljs.highlightAll()
</script>

    </div>
</div>
</body>
</html>
